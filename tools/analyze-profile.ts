/**
 * Electron Profile Analyzer
 *
 * Analyzes CPU profile traces generated by Electron's contentTracing module.
 *
 * Usage:
 *   node tools/analyze-profile.js <profile-file.json>
 *
 * Or with tsx/ts-node (requires proper tsconfig):
 *   npx tsx tools/analyze-profile.ts <profile-file.json>
 *
 * The tool outputs:
 * - Process summary (browser, renderers, GPU, etc.)
 * - Slowest individual operations
 * - Aggregated time by operation type
 * - Animation frame rates per renderer
 * - Garbage collection stats
 * - Long tasks (>50ms)
 */

// eslint-disable-next-line @typescript-eslint/no-require-imports
const fs = require('fs');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const path = require('path');

interface TraceEvent {
  name: string;
  cat: string;
  ph: string; // Phase: B=begin, E=end, X=complete, M=metadata, etc.
  pid: number;
  tid: number;
  ts: number; // Timestamp in microseconds
  dur?: number; // Duration in microseconds (for X phase events)
  args?: Record<string, unknown>;
}

interface TraceData {
  traceEvents: TraceEvent[];
}

interface ProcessInfo {
  pid: number;
  name: string;
  threadNames: Map<number, string>;
  totalDuration: number;
  eventCount: number;
}

interface AggregatedEvent {
  name: string;
  totalDuration: number;
  count: number;
  maxDuration: number;
  category: string;
}

function formatDuration(microseconds: number): string {
  if (microseconds >= 1_000_000) {
    return `${(microseconds / 1_000_000).toFixed(2)}s`;
  } else if (microseconds >= 1_000) {
    return `${(microseconds / 1_000).toFixed(2)}ms`;
  }
  return `${microseconds.toFixed(0)}Î¼s`;
}

function analyzeProfile(filePath: string): void {
  console.log(`\nğŸ“Š Analyzing profile: ${path.basename(filePath)}\n`);

  const fileContent = fs.readFileSync(filePath, 'utf-8');
  const data: TraceData = JSON.parse(fileContent);
  const events = data.traceEvents;

  console.log(`Total events: ${events.length.toLocaleString()}\n`);

  // Build process info map
  const processes = new Map<number, ProcessInfo>();
  const aggregatedEvents = new Map<string, AggregatedEvent>();
  const animationFrames = new Map<number, number[]>(); // pid -> timestamps
  const gcEvents: { pid: number; duration: number; name: string }[] = [];
  const longTasks: {
    name: string;
    duration: number;
    pid: number;
    category: string;
  }[] = [];

  // First pass: collect metadata
  for (const event of events) {
    if (event.ph === 'M' && event.name === 'thread_name') {
      let proc = processes.get(event.pid);
      if (!proc) {
        proc = {
          pid: event.pid,
          name: 'Unknown',
          threadNames: new Map(),
          totalDuration: 0,
          eventCount: 0,
        };
        processes.set(event.pid, proc);
      }
      const threadName = (event.args?.name as string) || 'Unknown';
      proc.threadNames.set(event.tid, threadName);

      // Identify process type from main thread name
      if (
        threadName === 'CrBrowserMain' ||
        threadName === 'CrRendererMain' ||
        threadName === 'CrGpuMain' ||
        threadName.includes('CrUtilityMain')
      ) {
        if (threadName === 'CrBrowserMain') proc.name = 'Browser (Main)';
        else if (threadName === 'CrRendererMain') proc.name = 'Renderer';
        else if (threadName === 'CrGpuMain') proc.name = 'GPU';
        else if (threadName.includes('network')) proc.name = 'Network';
        else if (threadName.includes('tracing')) proc.name = 'Tracing';
        else proc.name = 'Utility';
      }
    }
  }

  // Second pass: analyze events
  let minTimestamp = Infinity;
  let maxTimestamp = 0;

  for (const event of events) {
    if (event.ts > 0) {
      minTimestamp = Math.min(minTimestamp, event.ts);
      maxTimestamp = Math.max(maxTimestamp, event.ts + (event.dur || 0));
    }

    // Skip metadata events for duration analysis
    if (event.ph === 'M' || !event.dur) continue;

    const proc = processes.get(event.pid);
    if (proc) {
      proc.totalDuration += event.dur;
      proc.eventCount++;
    }

    // Aggregate events by name
    const key = `${event.name}|${event.cat}`;
    let agg = aggregatedEvents.get(key);
    if (!agg) {
      agg = {
        name: event.name,
        totalDuration: 0,
        count: 0,
        maxDuration: 0,
        category: event.cat,
      };
      aggregatedEvents.set(key, agg);
    }
    agg.totalDuration += event.dur;
    agg.count++;
    agg.maxDuration = Math.max(agg.maxDuration, event.dur);

    // Track animation frames
    if (
      event.name === 'RequestAnimationFrame' ||
      event.name === 'FireAnimationFrame'
    ) {
      let frames = animationFrames.get(event.pid);
      if (!frames) {
        frames = [];
        animationFrames.set(event.pid, frames);
      }
      frames.push(event.ts);
    }

    // Track GC events
    if (
      event.name.includes('GC') ||
      event.name.includes('MinorGC') ||
      event.name.includes('MajorGC') ||
      event.cat.includes('v8.gc')
    ) {
      gcEvents.push({ pid: event.pid, duration: event.dur, name: event.name });
    }

    // Track long tasks (>50ms)
    if (event.dur > 50_000) {
      longTasks.push({
        name: event.name,
        duration: event.dur,
        pid: event.pid,
        category: event.cat,
      });
    }
  }

  const totalDuration = maxTimestamp - minTimestamp;
  console.log(`Profile duration: ${formatDuration(totalDuration)}\n`);

  // Print process summary
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ“¦ PROCESS SUMMARY');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  const sortedProcesses = Array.from(processes.values())
    .filter((p) => p.eventCount > 0)
    .sort((a, b) => b.totalDuration - a.totalDuration);

  for (const proc of sortedProcesses) {
    console.log(
      `\n${proc.name} (PID: ${proc.pid}):`,
      `\n  Events: ${proc.eventCount.toLocaleString()}`,
      `\n  Total CPU time: ${formatDuration(proc.totalDuration)}`
    );
  }

  // Print slowest operations
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸŒ SLOWEST INDIVIDUAL OPERATIONS (Top 20)');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  const sortedByMax = Array.from(aggregatedEvents.values())
    .sort((a, b) => b.maxDuration - a.maxDuration)
    .slice(0, 20);

  for (const event of sortedByMax) {
    console.log(
      `${formatDuration(event.maxDuration).padStart(10)} | ${event.name} (${event.category})`
    );
  }

  // Print aggregated time by operation
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('â±ï¸  AGGREGATED TIME BY OPERATION (Top 30)');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  const sortedByTotal = Array.from(aggregatedEvents.values())
    .sort((a, b) => b.totalDuration - a.totalDuration)
    .slice(0, 30);

  for (const event of sortedByTotal) {
    const avgDuration = event.totalDuration / event.count;
    console.log(
      `${formatDuration(event.totalDuration).padStart(10)} total | ` +
        `${formatDuration(avgDuration).padStart(8)} avg | ` +
        `${event.count.toString().padStart(6)} calls | ${event.name}`
    );
  }

  // Print animation frame rates
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸï¸  ANIMATION FRAME RATES BY RENDERER');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  for (const [pid, timestamps] of animationFrames) {
    if (timestamps.length < 2) continue;
    timestamps.sort((a, b) => a - b);

    const proc = processes.get(pid);
    const procName = proc?.name || 'Unknown';

    // Calculate frame intervals
    const intervals: number[] = [];
    for (let i = 1; i < timestamps.length; i++) {
      intervals.push(timestamps[i] - timestamps[i - 1]);
    }

    const avgInterval =
      intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const avgFps = 1_000_000 / avgInterval;
    const minInterval = Math.min(...intervals);
    const maxFps = 1_000_000 / minInterval;

    console.log(
      `${procName} (PID: ${pid}):`,
      `\n  Frame count: ${timestamps.length}`,
      `\n  Avg FPS: ${avgFps.toFixed(1)}`,
      `\n  Peak FPS: ${maxFps.toFixed(1)}`,
      `\n  Avg frame time: ${formatDuration(avgInterval)}\n`
    );
  }

  // Print GC summary
  if (gcEvents.length > 0) {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸ—‘ï¸  GARBAGE COLLECTION SUMMARY');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    const totalGcTime = gcEvents.reduce((sum, e) => sum + e.duration, 0);
    const maxGc = Math.max(...gcEvents.map((e) => e.duration));
    const avgGc = totalGcTime / gcEvents.length;

    console.log(`Total GC events: ${gcEvents.length}`);
    console.log(`Total GC time: ${formatDuration(totalGcTime)}`);
    console.log(`Average GC pause: ${formatDuration(avgGc)}`);
    console.log(`Longest GC pause: ${formatDuration(maxGc)}`);
    console.log(
      `GC time as % of profile: ${((totalGcTime / totalDuration) * 100).toFixed(2)}%`
    );
  }

  // Print long tasks
  if (longTasks.length > 0) {
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âš ï¸  LONG TASKS (>50ms) - Top 20');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    const sortedLongTasks = longTasks
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 20);

    for (const task of sortedLongTasks) {
      const proc = processes.get(task.pid);
      const procName = proc?.name || 'Unknown';
      console.log(
        `${formatDuration(task.duration).padStart(10)} | ${procName.padEnd(15)} | ${task.name} (${task.category})`
      );
    }
  }

  // Print React-specific analysis
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('âš›ï¸  REACT/RENDERING ANALYSIS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  const reactEvents = Array.from(aggregatedEvents.values()).filter(
    (e) =>
      e.name.includes('FunctionCall') ||
      e.name.includes('EvaluateScript') ||
      e.name.includes('v8.compile') ||
      e.name.includes('UpdateLayoutTree') ||
      e.name.includes('Layout') ||
      e.name.includes('Paint') ||
      e.name.includes('Recalculate')
  );

  for (const event of reactEvents
    .sort((a, b) => b.totalDuration - a.totalDuration)
    .slice(0, 15)) {
    const avgDuration = event.totalDuration / event.count;
    console.log(
      `${event.name}:`,
      `\n  Total: ${formatDuration(event.totalDuration)} | ` +
        `Avg: ${formatDuration(avgDuration)} | ` +
        `Count: ${event.count}\n`
    );
  }

  // Performance recommendations
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ’¡ PERFORMANCE INSIGHTS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  const insights: string[] = [];

  // Check for high FPS (wasted renders)
  for (const [pid, timestamps] of animationFrames) {
    if (timestamps.length < 10) continue;
    const intervals: number[] = [];
    for (let i = 1; i < timestamps.length; i++) {
      intervals.push(timestamps[i] - timestamps[i - 1]);
    }
    const avgInterval =
      intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const avgFps = 1_000_000 / avgInterval;

    if (avgFps > 65) {
      const proc = processes.get(pid);
      insights.push(
        `âš ï¸  ${proc?.name || 'Renderer'} (PID: ${pid}) running at ${avgFps.toFixed(0)} FPS - consider throttling updates`
      );
    }
  }

  // Check for excessive GC
  if (gcEvents.length > 0) {
    const totalGcTime = gcEvents.reduce((sum, e) => sum + e.duration, 0);
    const gcPercent = (totalGcTime / totalDuration) * 100;
    if (gcPercent > 5) {
      insights.push(
        `âš ï¸  High GC overhead (${gcPercent.toFixed(1)}%) - check for memory leaks or excessive object creation`
      );
    }
  }

  // Check for long tasks
  const veryLongTasks = longTasks.filter((t) => t.duration > 100_000);
  if (veryLongTasks.length > 0) {
    insights.push(
      `âš ï¸  ${veryLongTasks.length} tasks over 100ms detected - may cause UI jank`
    );
  }

  // Check for Layout thrashing
  const layoutEvents = aggregatedEvents.get('Layout|devtools.timeline');
  if (layoutEvents && layoutEvents.count > 100) {
    insights.push(
      `âš ï¸  ${layoutEvents.count} layout operations - potential layout thrashing`
    );
  }

  if (insights.length === 0) {
    console.log('âœ… No major performance issues detected!');
  } else {
    for (const insight of insights) {
      console.log(insight);
    }
  }

  console.log('\n');
}

// Main execution
const args = process.argv.slice(2);
if (args.length === 0) {
  console.log('Usage: npx ts-node tools/analyze-profile.ts <profile-file.json>');
  console.log('\nExample:');
  console.log(
    '  npx ts-node tools/analyze-profile.ts ~/Desktop/irdashies-profile-2025-12-06.json'
  );
  process.exit(1);
}

const filePath = args[0];
if (!fs.existsSync(filePath)) {
  console.error(`Error: File not found: ${filePath}`);
  process.exit(1);
}

try {
  analyzeProfile(filePath);
} catch (error) {
  console.error('Error analyzing profile:', error);
  process.exit(1);
}
