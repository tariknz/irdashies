/**
 * Memory Analysis Guide for Electron Apps
 *
 * This script provides guidance on analyzing memory usage in Electron apps.
 * It can also parse memory reports generated by the app's Memory menu.
 *
 * Usage:
 *   npx tsx tools/analyze-memory.ts [memory-report.json]
 */

import fs from 'fs';
import path from 'path';

interface MemoryReport {
  timestamp: string;
  main: {
    heapUsed: number;
    heapTotal: number;
    rss: number;
    external: number;
    arrayBuffers: number;
  };
  renderers: {
    id: number;
    title: string;
    memory: {
      private: number;
    };
  }[];
  system: {
    private: number;
  };
  summary: {
    totalMB: number;
    mainHeapMB: number;
    renderersPrivateMB: number;
  };
}

function formatMB(bytes: number): string {
  return (bytes / 1024 / 1024).toFixed(2);
}

function analyzeMemoryReport(filePath: string): void {
  console.log(`\nğŸ“Š Analyzing memory report: ${path.basename(filePath)}\n`);

  const fileContent = fs.readFileSync(filePath, 'utf-8');
  const report: MemoryReport = JSON.parse(fileContent);

  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ§  MEMORY BREAKDOWN');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  console.log('ğŸ“¦ MAIN PROCESS:');
  console.log(`   Heap Used:      ${formatMB(report.main.heapUsed)} MB`);
  console.log(`   Heap Total:     ${formatMB(report.main.heapTotal)} MB`);
  console.log(`   RSS:            ${formatMB(report.main.rss)} MB`);
  console.log(`   External:       ${formatMB(report.main.external)} MB`);
  console.log(`   Array Buffers:  ${formatMB(report.main.arrayBuffers)} MB`);

  console.log('\nğŸ–¼ï¸  RENDERER PROCESSES:');
  let totalRendererMem = 0;
  for (const renderer of report.renderers) {
    console.log(`   ${renderer.title}: ${formatMB(renderer.memory.private)} MB`);
    totalRendererMem += renderer.memory.private;
  }

  console.log('\nğŸ“Š SUMMARY:');
  console.log(`   Total Process Memory:  ${report.summary.totalMB.toFixed(2)} MB`);
  console.log(`   Main Heap Used:        ${report.summary.mainHeapMB.toFixed(2)} MB`);
  console.log(`   Renderers (${report.renderers.length}):       ${formatMB(totalRendererMem)} MB`);

  // Analysis
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ’¡ ANALYSIS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  const insights: string[] = [];

  // Check main process heap
  const mainHeapMB = report.main.heapUsed / 1024 / 1024;
  if (mainHeapMB > 100) {
    insights.push(`âš ï¸  Main process heap is ${mainHeapMB.toFixed(0)}MB - check for data accumulation`);
  }

  // Check number of renderers
  if (report.renderers.length > 5) {
    insights.push(`ğŸ“Œ ${report.renderers.length} renderer processes - each overlay window uses memory`);
  }

  // Check individual renderer sizes
  for (const renderer of report.renderers) {
    const memMB = renderer.memory.private / 1024 / 1024;
    if (memMB > 150) {
      insights.push(`âš ï¸  "${renderer.title}" using ${memMB.toFixed(0)}MB - may have DevTools open or memory leak`);
    }
  }

  // Estimate expected memory
  const expectedBaseMemory = 150; // Main + GPU process
  const expectedPerRenderer = 80; // ~80MB per renderer
  const expectedTotal = expectedBaseMemory + (report.renderers.length * expectedPerRenderer);
  const actualTotal = report.summary.totalMB;

  if (actualTotal > expectedTotal * 1.5) {
    insights.push(`âš ï¸  Memory usage (${actualTotal.toFixed(0)}MB) is higher than expected (~${expectedTotal.toFixed(0)}MB)`);
    insights.push(`   Possible causes:`);
    insights.push(`   - DevTools open in renderer windows`);
    insights.push(`   - Memory leaks in React components`);
    insights.push(`   - Large data structures not being cleaned up`);
  }

  if (insights.length === 0) {
    console.log('âœ… Memory usage looks normal for the number of windows');
    console.log(`   Expected: ~${expectedTotal}MB for ${report.renderers.length} overlay(s)`);
  } else {
    for (const insight of insights) {
      console.log(insight);
    }
  }

  console.log('\n');
}

function showHelp(): void {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            ELECTRON MEMORY PROFILING GUIDE                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ QUICK REFERENCE

  Expected memory per component:
  â”œâ”€â”€ Main Process:     50-100 MB
  â”œâ”€â”€ GPU Process:      50-150 MB
  â”œâ”€â”€ Each Renderer:    80-150 MB
  â””â”€â”€ DevTools (open):  100-300 MB extra per window

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ” HOW TO INVESTIGATE HIGH MEMORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. CHECK PROCESS COUNT
   - Use Task Manager (Windows) or Activity Monitor (Mac)
   - Look for "irDashies" or "Electron" processes
   - Each overlay = 1 renderer process

2. TAKE HEAP SNAPSHOT (Main Process)
   - Tray menu â†’ Memory â†’ Take Heap Snapshot
   - Open in Chrome DevTools â†’ Memory tab
   - Look for:
     â€¢ Large retained objects
     â€¢ Growing arrays/maps
     â€¢ Duplicate strings

3. TAKE HEAP SNAPSHOT (Renderer)
   - Open DevTools in any overlay (unlock first)
   - Go to Memory tab â†’ Take Heap Snapshot
   - Compare snapshots over time to find leaks

4. CHECK FOR DEVTOOLS
   - DevTools consumes 100-300MB when open
   - Close DevTools in all windows when not debugging

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ› COMMON MEMORY LEAK PATTERNS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. UNCLEARED INTERVALS/TIMEOUTS
   setInterval(() => {...}, 1000);  // âŒ Never cleared
   
   const id = setInterval(...);
   return () => clearInterval(id);  // âœ… Cleanup

2. EVENT LISTENER LEAKS
   window.addEventListener('resize', handler);  // âŒ Never removed
   
   useEffect(() => {
     window.addEventListener('resize', handler);
     return () => window.removeEventListener('resize', handler);  // âœ…
   }, []);

3. GROWING DATA STRUCTURES
   // âŒ Data grows forever
   const history = [];
   history.push(newData);
   
   // âœ… Limit size
   if (history.length > MAX_SIZE) history.shift();

4. ZUSTAND/REACT STATE ACCUMULATION
   // Check stores for growing Maps/Arrays:
   - RelativeGapStore (car histories)
   - FuelStore (lap history)
   - LapTimesStore (lap times)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š ANALYZE A MEMORY REPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Usage: node tools/analyze-memory.ts <memory-report.json>

Generate a report via: Tray â†’ Memory â†’ Save Memory Report

`);
}

// Main execution
const args = process.argv.slice(2);

if (args.length === 0) {
  showHelp();
  process.exit(0);
}

const filePath = args[0];

if (args[0] === '--help' || args[0] === '-h') {
  showHelp();
  process.exit(0);
}

if (!fs.existsSync(filePath)) {
  console.error(`Error: File not found: ${filePath}`);
  process.exit(1);
}

try {
  analyzeMemoryReport(filePath);
} catch (error) {
  console.error('Error analyzing memory report:', error);
  process.exit(1);
}
